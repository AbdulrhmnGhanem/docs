var documenterSearchIndex = {"docs":
[{"location":"userguide/editingcode/#Editing-Code-1","page":"Editing Code","title":"Editing Code","text":"","category":"section"},{"location":"devdocs/devdocs/#Developer-Documentation-1","page":"Overview","title":"Developer Documentation","text":"","category":"section"},{"location":"userguide/compilesysimage/#Compiling-Sysimages-1","page":"Compiling Sysimages","title":"Compiling Sysimages","text":"","category":"section"},{"location":"userguide/compilesysimage/#","page":"Compiling Sysimages","title":"Compiling Sysimages","text":"The Julia VS Code extension makes it easy to compile a custom sysimage for your Julia environments. The extension will also automatically use sysimages for the current environment when it starts a new Julia REPL in VS Code.","category":"page"},{"location":"userguide/compilesysimage/#","page":"Compiling Sysimages","title":"Compiling Sysimages","text":"Custom sysimages can significantly reduce load times for packages.","category":"page"},{"location":"userguide/compilesysimage/#Creating-a-sysimage-for-the-active-environment-1","page":"Compiling Sysimages","title":"Creating a sysimage for the active environment","text":"","category":"section"},{"location":"userguide/compilesysimage/#","page":"Compiling Sysimages","title":"Compiling Sysimages","text":"The Julia extension adds a build task for custom sysimages to the Visual Studio Code task system. To run this build task, select the command Tasks: Run Build Task and then select Julia: Build custom sysimage for current environment.","category":"page"},{"location":"userguide/compilesysimage/#","page":"Compiling Sysimages","title":"Compiling Sysimages","text":"The build task will create a sysimage that includes all packages in the current Julia environment. This sysimage will be saved in the same folder where the Project.toml and Manifest.toml of the current Julia environment are stored. The name of the sysimage file will be JuliaSysimage.dll (Windows) or JuliaSysimage.so.","category":"page"},{"location":"userguide/compilesysimage/#Using-custom-sysimages-1","page":"Compiling Sysimages","title":"Using custom sysimages","text":"","category":"section"},{"location":"userguide/compilesysimage/#","page":"Compiling Sysimages","title":"Compiling Sysimages","text":"Whenever the Julia extension starts a new Julia REPL process, it will first look whether a custom sysimage file exists for the current Julia environment, and whether this custom sysimage file is up-to-date (by comparing the last modified date of the sysimage file with the last modified date of the Manifest.toml file). If an up-to-date sysimage file exists, the Julia extension will automatically start the Julia REPL process with this custom sysimage loaded.","category":"page"},{"location":"userguide/understandingcode/#Understanding-Code-1","page":"Understanding Code","title":"Understanding Code","text":"","category":"section"},{"location":"setup/#Setup-1","page":"Setup","title":"Setup","text":"","category":"section"},{"location":"setup/#","page":"Setup","title":"Setup","text":"Getting the Julia extension for VS Code to work involves two steps:","category":"page"},{"location":"setup/#","page":"Setup","title":"Setup","text":"Install VS Code and then,\nInstall the Julia extension. ","category":"page"},{"location":"setup/#","page":"Setup","title":"Setup","text":"In rare situations you also need to configure the extension to find your Julia installation.","category":"page"},{"location":"setup/#Installing-VS-Code-1","page":"Setup","title":"Installing VS Code","text":"","category":"section"},{"location":"setup/#","page":"Setup","title":"Setup","text":"Just head over to the VS Code homepage. \nFollow the installation instructions for your platform. ","category":"page"},{"location":"setup/#","page":"Setup","title":"Setup","text":"At the end of this step you should be able to start VS Code.","category":"page"},{"location":"setup/#Install-the-Julia-extension-1","page":"Setup","title":"Install the Julia extension","text":"","category":"section"},{"location":"setup/#","page":"Setup","title":"Setup","text":"First, start VS Code.\nInside VS Code, go to the extensions view either by executing the View: Show Extensions command (click View->Command Palette...) or by clicking on the extension icon on the left side of the VS Code window.\nIn the extensions view, simply search for the term julia in the marketplace search box, then select the Julia extension and click the install button. \nYou might have to restart VS Code after this step.","category":"page"},{"location":"setup/#Configure-the-Julia-extension-1","page":"Setup","title":"Configure the Julia extension","text":"","category":"section"},{"location":"setup/#","page":"Setup","title":"Setup","text":"If you have installed Julia into a standard location on Mac or Windows, or if the Julia binary is on your PATH, the Julia VS Code extension should automatically find your Julia installation and you should not need to configure anything.\nIf the extension does not find your Julia installation automatically, or if you want to use a different Julia installation than the default one,\nYou can set the julia.executablePath to the full path of Julia executable that the extension should use. In that case the extension will always use that version of Julia.\nTo edit your configuration settings, \nexecute the Preferences: Open User Settings command (you can also access it via the menu File->Preferences->Settings),\nAnd then make sure your user settings include the julia.executablePath setting.\nThe format of the string should follow your platform specific conventions, and be aware that the backlash \\ is the escape character in JSON, so you need to use \\\\ as the path separator character on Windows.","category":"page"},{"location":"userguide/remote/#Remote-Development-1","page":"Remote Development","title":"Remote Development","text":"","category":"section"},{"location":"release-notes/v0_17/#Julia-VS-Code-extension-v0.17-release-1","page":"Julia VS Code extension v0.17 release","title":"Julia VS Code extension v0.17 release","text":"","category":"section"},{"location":"release-notes/v0_17/#","page":"Julia VS Code extension v0.17 release","title":"Julia VS Code extension v0.17 release","text":"Welcome to the v0.17 release of the Julia VS Code extension.","category":"page"},{"location":"release-notes/v0_17/#Global-variable-support-in-the-debugger-variable-explorer-1","page":"Julia VS Code extension v0.17 release","title":"Global variable support in the debugger variable explorer","text":"","category":"section"},{"location":"release-notes/v0_17/#","page":"Julia VS Code extension v0.17 release","title":"Julia VS Code extension v0.17 release","text":"The Variables pane in the integrated debugger now supports global variables:","category":"page"},{"location":"release-notes/v0_17/#","page":"Julia VS Code extension v0.17 release","title":"Julia VS Code extension v0.17 release","text":"(Image: globals in debugger)","category":"page"},{"location":"release-notes/v0_17/#","page":"Julia VS Code extension v0.17 release","title":"Julia VS Code extension v0.17 release","text":"Globals shows global variables used in the current function's scope, whereas Global (...) shows all global variables defined in the current scope's enclosing module. All of these can be edited, but be vary of unexpected behaviour.","category":"page"},{"location":"release-notes/v0_17/#Debug-and-run-buttons-above-Julia-files-1","page":"Julia VS Code extension v0.17 release","title":"Debug and run buttons above Julia files","text":"","category":"section"},{"location":"release-notes/v0_17/#","page":"Julia VS Code extension v0.17 release","title":"Julia VS Code extension v0.17 release","text":"We added a run and debug button above the file editor area when you open a Julia file that makes it easier to run the currently active file:","category":"page"},{"location":"release-notes/v0_17/#","page":"Julia VS Code extension v0.17 release","title":"Julia VS Code extension v0.17 release","text":"(Image: run-debugger buttons)","category":"page"},{"location":"release-notes/v0_17/#Support-for-step-in-targets-in-the-debugger-1","page":"Julia VS Code extension v0.17 release","title":"Support for step in targets in the debugger","text":"","category":"section"},{"location":"release-notes/v0_17/#","page":"Julia VS Code extension v0.17 release","title":"Julia VS Code extension v0.17 release","text":"VSCode now supports a new \"Step into Targets\" debugger UI, which you can access by opening the context menu in an editor while debugging. It will allow you to step into a function call on the current line:","category":"page"},{"location":"release-notes/v0_17/#","page":"Julia VS Code extension v0.17 release","title":"Julia VS Code extension v0.17 release","text":"(Image: debugger: step into targets)","category":"page"},{"location":"release-notes/v0_17/#Profile-viewing-support-1","page":"Julia VS Code extension v0.17 release","title":"Profile viewing support","text":"","category":"section"},{"location":"release-notes/v0_17/#","page":"Julia VS Code extension v0.17 release","title":"Julia VS Code extension v0.17 release","text":"We added new functionality that allows you to save profiling results in a *.cpuprofile file. Recent versions of VS Code have built-in support to analyze and visualize these profiling result files.","category":"page"},{"location":"release-notes/v0_17/#","page":"Julia VS Code extension v0.17 release","title":"Julia VS Code extension v0.17 release","text":"The easiest way to use this functionality is the @profview macro, which executes your code under the Julia profiler and then saves the results as a *.cpuprofile file. To use it, start a Julia REPL, and then call @profview like this:","category":"page"},{"location":"release-notes/v0_17/#","page":"Julia VS Code extension v0.17 release","title":"Julia VS Code extension v0.17 release","text":"julia> @profview my_function_that_should_be_profiled()","category":"page"},{"location":"release-notes/v0_17/#","page":"Julia VS Code extension v0.17 release","title":"Julia VS Code extension v0.17 release","text":"Alternatively you can call the function view_profile in the REPL which will save the profiling results from the previous profiling session.","category":"page"},{"location":"release-notes/v0_17/#","page":"Julia VS Code extension v0.17 release","title":"Julia VS Code extension v0.17 release","text":"Once you have created a *.cpuprofile file with one of these methods, you can open it in VS Code. The initial view shown is a tabular display of the profiling results. The search bar at the top allows you to filter the profiling results and provides a rich query language for more advanced queries:","category":"page"},{"location":"release-notes/v0_17/#","page":"Julia VS Code extension v0.17 release","title":"Julia VS Code extension v0.17 release","text":"(Image: profiler table view)","category":"page"},{"location":"release-notes/v0_17/#","page":"Julia VS Code extension v0.17 release","title":"Julia VS Code extension v0.17 release","text":"You can also look at the same information in a flamegraph by clicking the little fire button next to the search area. The first time you do so, you will be asked to install another extension, go ahead and do that. The flamegraph visualization then looks like this:","category":"page"},{"location":"release-notes/v0_17/#","page":"Julia VS Code extension v0.17 release","title":"Julia VS Code extension v0.17 release","text":"(Image: profiler flame view)","category":"page"},{"location":"release-notes/v0_17/#","page":"Julia VS Code extension v0.17 release","title":"Julia VS Code extension v0.17 release","text":"Special thanks to Valentin and Connor for their help with this feature!","category":"page"},{"location":"release-notes/v0_17/#Inline-result-styling-improvements-1","page":"Julia VS Code extension v0.17 release","title":"Inline result styling improvements","text":"","category":"section"},{"location":"release-notes/v0_17/#","page":"Julia VS Code extension v0.17 release","title":"Julia VS Code extension v0.17 release","text":"The stylings of inline result bubbles are greatly improved; the left-border color will make it easier to distinguish them from the actual code:","category":"page"},{"location":"release-notes/v0_17/#","page":"Julia VS Code extension v0.17 release","title":"Julia VS Code extension v0.17 release","text":"in dark theme (Iceberg): (Image: inline bubbles dark)\nin light theme (Night Owl Light): (Image: inline bubbles light)","category":"page"},{"location":"release-notes/v0_17/#Stackframe-highlighting-for-inline-evaluations-1","page":"Julia VS Code extension v0.17 release","title":"Stackframe highlighting for inline evaluations","text":"","category":"section"},{"location":"release-notes/v0_17/#","page":"Julia VS Code extension v0.17 release","title":"Julia VS Code extension v0.17 release","text":"Now our inline execution will highlight all lines in backtrace when you hit an error: (Image: stackframe highlight)","category":"page"},{"location":"release-notes/v0_17/#","page":"Julia VS Code extension v0.17 release","title":"Julia VS Code extension v0.17 release","text":"If you hover your mouse over any of the lines, the detail of the error will show up and you can goto whichever frame in a backtrace by clicking the links: (Image: stackframe hover)","category":"page"},{"location":"release-notes/v0_17/#","page":"Julia VS Code extension v0.17 release","title":"Julia VS Code extension v0.17 release","text":"Additionally, the topmost buttons allow you to go to first/previous/next/last frames, and clear all the traces: (Image: stackframe buttons)","category":"page"},{"location":"release-notes/v0_17/#","page":"Julia VS Code extension v0.17 release","title":"Julia VS Code extension v0.17 release","text":"We also added the improvement to cut off the julia-vscode extension's internal lines from backtrace so that they won't appear in users' stackframe.","category":"page"},{"location":"release-notes/v0_17/#Configuration-option-to-exclude-folders-from-linting-1","page":"Julia VS Code extension v0.17 release","title":"Configuration option to exclude folders from linting","text":"","category":"section"},{"location":"release-notes/v0_17/#","page":"Julia VS Code extension v0.17 release","title":"Julia VS Code extension v0.17 release","text":"We've added an new configuration option julia.lint.disabledDirs. It specifies sub-directories in a package directory where only basic linting is enabled, and this will drastically lowers the chance for false positives. By default, test and docs are set, so most problematic errors (e.g. \"Missing reference ...\") will be suppressed there.","category":"page"},{"location":"release-notes/v0_17/#","page":"Julia VS Code extension v0.17 release","title":"Julia VS Code extension v0.17 release","text":"Note this config is only a temporary fix for our environment handling – we will work on redesigning the whole environment handling, which will hopefully get rid of most of those false positives, and then we may probably remove this configuration in the future.","category":"page"},{"location":"release-notes/v0_17/#Extension-API-1","page":"Julia VS Code extension v0.17 release","title":"Extension API","text":"","category":"section"},{"location":"release-notes/v0_17/#","page":"Julia VS Code extension v0.17 release","title":"Julia VS Code extension v0.17 release","text":"This extension now exports an API, which can be consumed by other VSCode extensions (see the VSCode docs for more info). Version 1 of the API exports the async getJuliaPath() and async getEnvironment() functions.","category":"page"},{"location":"release-notes/v0_17/#Bugfixes-1","page":"Julia VS Code extension v0.17 release","title":"Bugfixes","text":"","category":"section"},{"location":"release-notes/v0_17/#","page":"Julia VS Code extension v0.17 release","title":"Julia VS Code extension v0.17 release","text":"We've also fixed a plethora of issues across the entire extension.","category":"page"},{"location":"userguide/tasks/#Tasks-1","page":"Tasks","title":"Tasks","text":"","category":"section"},{"location":"userguide/grid/#Data-Grid-1","page":"Data Grid","title":"Data Grid","text":"","category":"section"},{"location":"userguide/formatter/#Formatting-Code-1","page":"Formatting Code","title":"Formatting Code","text":"","category":"section"},{"location":"userguide/linter/#Linter-1","page":"Linter","title":"Linter","text":"","category":"section"},{"location":"gettingstarted/#Getting-Started-1","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"release-notes/v0_16/#Julia-VS-Code-extension-v0.16-release-1","page":"Version v0.16","title":"Julia VS Code extension v0.16 release","text":"","category":"section"},{"location":"release-notes/v0_16/#","page":"Version v0.16","title":"Version v0.16","text":"Welcome to the v0.16 release of the Julia VS Code extension.","category":"page"},{"location":"release-notes/v0_16/#Inline-evaluation-1","page":"Version v0.16","title":"Inline evaluation","text":"","category":"section"},{"location":"release-notes/v0_16/#","page":"Version v0.16","title":"Version v0.16","text":"Code evaluation has been overhauled for this release.","category":"page"},{"location":"release-notes/v0_16/#","page":"Version v0.16","title":"Version v0.16","text":"The Julia: Execute * (e.g. Julia: Execute Code And Move, by default accessible with Alt-Enter) commands now asynchronously evaluate the selection, current code block, or file. These commands also evaluate the code in the context of their containing module, which is indicated in the status bar:","category":"page"},{"location":"release-notes/v0_16/#","page":"Version v0.16","title":"Version v0.16","text":"(Image: )","category":"page"},{"location":"release-notes/v0_16/#","page":"Version v0.16","title":"Version v0.16","text":"You can change the module for a file by clicking on the module indicator or by calling the Julia: Select Current Module command (e.g. with the Ctrl-J Ctrl-M keybinding).","category":"page"},{"location":"release-notes/v0_16/#","page":"Version v0.16","title":"Version v0.16","text":"Evaluating code directly into a module is especially helpful for a Revise-less workflow – it allows you to easily update methods or globals.","category":"page"},{"location":"release-notes/v0_16/#","page":"Version v0.16","title":"Version v0.16","text":"Another new feature in this release are inline results for code evaluated from the editor. To enable them, select the inline result type in the extension's Julia > Execution: Result Type setting.","category":"page"},{"location":"release-notes/v0_16/#","page":"Version v0.16","title":"Version v0.16","text":"Inline results display the first line of the result's plain-text representation (via Base.show). Details are available by hovering over the result, like in the screenshot below (make sure you have the Editor > Hover: Enabled setting ticked):","category":"page"},{"location":"release-notes/v0_16/#","page":"Version v0.16","title":"Version v0.16","text":"(Image: )","category":"page"},{"location":"release-notes/v0_16/#","page":"Version v0.16","title":"Version v0.16","text":"The inline result on the current line can be cleared with Julia: Clear Current Inline Result (Ctrl-I Ctrl-D); all inline results in the active text editor are cleared with Julia: Clear All Inline Results (Ctrl-I Ctrl-C).","category":"page"},{"location":"release-notes/v0_16/#","page":"Version v0.16","title":"Version v0.16","text":"We're still working on inline evaluation, inline results, and related features, so expect more changes in the following releases.","category":"page"},{"location":"release-notes/v0_16/#","page":"Version v0.16","title":"Version v0.16","text":"note: Note\nThe Julia: Send Current Line or Selection to REPL command simply copies the current line or selection and pastes it into the REPL, so it does not take the code's module into account.","category":"page"},{"location":"release-notes/v0_16/#Workspace-view-1","page":"Version v0.16","title":"Workspace view","text":"","category":"section"},{"location":"release-notes/v0_16/#","page":"Version v0.16","title":"Version v0.16","text":"It's now possible to inspect the current REPL's runtime state in the Workspace pane, which you can open with the View: Show Julia Explorer command or by clicking on the Julia symbol in the activity bar.","category":"page"},{"location":"release-notes/v0_16/#","page":"Version v0.16","title":"Version v0.16","text":"You can drill down into modules and find out what they define, inspect complex structs or dictionaries, and even inspect arbitrarily large arrays:","category":"page"},{"location":"release-notes/v0_16/#","page":"Version v0.16","title":"Version v0.16","text":"(Image: )","category":"page"},{"location":"release-notes/v0_16/#","page":"Version v0.16","title":"Version v0.16","text":"All of this lazy-loaded, so don't worry about recursive types or big arrays – we're taking great care not to influence the editor's performance or mess with Julia's GC.","category":"page"},{"location":"release-notes/v0_16/#","page":"Version v0.16","title":"Version v0.16","text":"Supported types like arrays (or other table-like objects) and plots can be shown in the integrated table viewer or plot pane with the click of a button.","category":"page"},{"location":"release-notes/v0_16/#Faster-REPL-startup-1","page":"Version v0.16","title":"Faster REPL startup","text":"","category":"section"},{"location":"release-notes/v0_16/#","page":"Version v0.16","title":"Version v0.16","text":"All code the extension loads into the REPL process is now in a (precompiled) module, which should speed up startup.","category":"page"},{"location":"release-notes/v0_16/#Bugfixes-1","page":"Version v0.16","title":"Bugfixes","text":"","category":"section"},{"location":"release-notes/v0_16/#","page":"Version v0.16","title":"Version v0.16","text":"We've also fixed a plethora of issues in the Language Server and the interactive code.","category":"page"},{"location":"userguide/plotgallery/#Plot-Gallery-1","page":"Plot Gallery","title":"Plot Gallery","text":"","category":"section"},{"location":"userguide/debugging/#Debugging-1","page":"Debugging","title":"Debugging","text":"","category":"section"},{"location":"userguide/codenavigation/#Code-Navigation-1","page":"Code Navigation","title":"Code Navigation","text":"","category":"section"},{"location":"userguide/codenavigation/#Open-Package-Directory-1","page":"Code Navigation","title":"Open Package Directory","text":"","category":"section"},{"location":"userguide/codenavigation/#Goto-Definition-1","page":"Code Navigation","title":"Goto Definition","text":"","category":"section"},{"location":"userguide/codenavigation/#Symbols-1","page":"Code Navigation","title":"Symbols","text":"","category":"section"},{"location":"userguide/runningcode/#Running-Code-1","page":"Running Code","title":"Running Code","text":"","category":"section"},{"location":"userguide/runningcode/#","page":"Running Code","title":"Running Code","text":"The Julia extension provides a number of different ways to run your Julia code. This section describes all these options, except how to run code in the debugger, which is covered in a separate part of the documentation.","category":"page"},{"location":"userguide/runningcode/#Running-a-Julia-file-1","page":"Running Code","title":"Running a Julia file","text":"","category":"section"},{"location":"userguide/runningcode/#","page":"Running Code","title":"Running Code","text":"The VS Code command Run: Start Without Debugging (Ctrl+F5) by default starts a new Julia instance and runs the currently active Julia file. The command automatically creates a new VS Code terminal for this Julia process.","category":"page"},{"location":"userguide/runningcode/#","page":"Running Code","title":"Running Code","text":"Note that the Julia instance that is started by this command is entirely independent from the Julia REPL that the extension also supports.","category":"page"},{"location":"userguide/runningcode/#","page":"Running Code","title":"Running Code","text":"You can easily customize the behavior of Run: Start Without Debugging by creating a launch configuration. In many situations it is for example beneficial to not run the currently active file, but instead configure one file in your workspace as the main entry point for your project that is run when you press Ctrl+F5. Other customization options include custom working directories, command line arguments or a specific Julia environment (that is distinct from the active Julia environment in the VS Code window). Launch configurations also allow you to configure more complex execution scenarios where multiple Julia and non-Julia scripts are started simultaneously via compound launch configurations.","category":"page"},{"location":"userguide/runningcode/#","page":"Running Code","title":"Running Code","text":"The Julia extension itself supports the following launch configuration attributes:","category":"page"},{"location":"userguide/runningcode/#","page":"Running Code","title":"Running Code","text":"program: a path to a .jl file. This is the Julia file that will be run when this launch configuration is used. If this attribute is not specified, it defaults to the currently active Julia file in the editor.\ncwd: a path to a folder. The Julia process that is started by the launch configuration will use this path as the initial working directory. If this attribute is not specified, it defaults to the root working folder open in VS Code.\njuliaEnv: a path to a Julia project. The Julia process will be started with this Julia project as the active project. If this attribute is not specified, it defaults to the currently active Julia environment in the VS Code window.\nargs: an array of command line arguments. The values specified in this list will be passed as command line arguments to the Julia process that is started and are available via the Base.ARGS variable in the Julia script. If this attribute is not specified, no command line arguments are passed to the Julia instance.","category":"page"},{"location":"userguide/runningcode/#The-Julia-REPL-1","page":"Running Code","title":"The Julia REPL","text":"","category":"section"},{"location":"userguide/runningcode/#","page":"Running Code","title":"Running Code","text":"The Julia extension provides a Julia REPL inside VS Code. You can start this REPL with the Julia: Start REPL command.","category":"page"},{"location":"userguide/runningcode/#","page":"Running Code","title":"Running Code","text":"The Julia REPL in the extension is identical to the default Julia REPL, but adds a number of additional integrations (plot pane, grid viewer, debugger etc.) that are not part of the standard REPL. Note that only the REPL that you start with the Julia: Start REPL command has these integrations. If you start Julia from a system shell inside VS Code, it won't provide these integration points.","category":"page"},{"location":"userguide/runningcode/#","page":"Running Code","title":"Running Code","text":"The REPL that is started with the Julia: Start REPL command will have the root folder of the currently active workspace as its working directory, and will be started with the Julia project that is currently active in the VS Code window.","category":"page"},{"location":"userguide/runningcode/#Running-code-in-the-Julia-REPL-1","page":"Running Code","title":"Running code in the Julia REPL","text":"","category":"section"},{"location":"userguide/runningcode/#","page":"Running Code","title":"Running Code","text":"There are four commands that you can use to run code from your editor in the Julia REPL: Julia: Execute Code (Ctrl+Enter), Julia: Execute Code Block (Alt+Enter), Julia: Execute Code Cell (Shift+Enter) and Julia: Execute File.","category":"page"},{"location":"userguide/runningcode/#Julia:-Execute-Code-(CtrlEnter)-1","page":"Running Code","title":"Julia: Execute Code (Ctrl+Enter)","text":"","category":"section"},{"location":"userguide/runningcode/#","page":"Running Code","title":"Running Code","text":"This command will either send the text that is currently selected in the active editor to the Julia REPL, or it will send the entire line where the cursor is currently positioned when no text is selected. In the latter case it will also advance the cursor to the next line of code.","category":"page"},{"location":"userguide/runningcode/#","page":"Running Code","title":"Running Code","text":"This command works a little bit like copy-paste: it will literally just copy some code from the editor into the REPL as if that code was typed in the REPL. This design has some consequences that you should keep in mind:","category":"page"},{"location":"userguide/runningcode/#","page":"Running Code","title":"Running Code","text":"when you send something like a function definition to the REPL, no line or file information will be associated with that function. This can be annoying later on, when exceptions that are thrown in this function will not show any location information.\ninclude statements will always try to load relative paths relative to the current working directory, not relative to the file from which they are executed.\nMacros like @__DIR__ and @__FILE__ do not work properly.","category":"page"},{"location":"userguide/runningcode/#","page":"Running Code","title":"Running Code","text":"Due to these limitations, most users should use the Julia: Execute Code Block command in most cases.","category":"page"},{"location":"userguide/runningcode/#Julia:-Execute-Code-Block-(AltEnter)-1","page":"Running Code","title":"Julia: Execute Code Block (Alt+Enter)","text":"","category":"section"},{"location":"userguide/runningcode/#","page":"Running Code","title":"Running Code","text":"Whenever there is some Julia code selected in the currently active editor, this command will execute the selected code. If no text is selected, the command will identify the extent of the top-level language construct that the cursor is located in (except modules) and execute that code block.","category":"page"},{"location":"userguide/runningcode/#","page":"Running Code","title":"Running Code","text":"This command uses a different execution model than Julia: Execute Code that provides a more robust experience. In particular, it will associate location information with code that is executed, include will work correctly with relative paths and macros like @__DIR__ and @__FILE__ work as expected.","category":"page"},{"location":"userguide/runningcode/#","page":"Running Code","title":"Running Code","text":"For most users this should be their default command to run Julia code in the REPL.","category":"page"},{"location":"userguide/runningcode/#Julia:-Execute-Code-Cell-(ShiftEnter)-1","page":"Running Code","title":"Julia: Execute Code Cell (Shift+Enter)","text":"","category":"section"},{"location":"userguide/runningcode/#","page":"Running Code","title":"Running Code","text":"The extension provides support for demarking code cells in standard Julia files with a specially formatted comment: ##. This command will identify in which code cell the cursor in the active editor currently is and then execute the code in that cell. If there are no code cells used in the current file, it will execute the entire file.","category":"page"},{"location":"userguide/runningcode/#","page":"Running Code","title":"Running Code","text":"This command uses the same code execution techniques as the Julia: Execute Code Block command. Include statements, location information etc. all work as expected for that that is run with this command.","category":"page"},{"location":"userguide/runningcode/#Julia:-Execute-File-1","page":"Running Code","title":"Julia: Execute File","text":"","category":"section"},{"location":"userguide/runningcode/#","page":"Running Code","title":"Running Code","text":"This command runs the entire content of the currently active file in the Julia REPL. It uses the same code execution techniques as the Julia: Execute Code Block command. Include statements, location information etc. all work as expected for that that is run with this command.","category":"page"},{"location":"userguide/weave/#Julia-Markdown-Documents-1","page":"Julia Markdown Documents","title":"Julia Markdown Documents","text":"","category":"section"},{"location":"#Home-1","page":"Home","title":"Home","text":"","category":"section"},{"location":"userguide/settings/#Settings-1","page":"Settings","title":"Settings","text":"","category":"section"},{"location":"userguide/env/#Julia-Environments-1","page":"Julia Environments","title":"Julia Environments","text":"","category":"section"}]
}
